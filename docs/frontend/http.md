# HTTP 网络协议
---
*2020/10/26*

## HTTP 协议

::: tip
  HTTP 是网络应用层的一个协议，重要性不言而喻，无论是 webservice 还是 rest 做大型架构，都离不开HTTP协议的认识，甚至可以简化的说：
* webservice = HTTP协议 + XML
* Rest = HTTP协议 + json
* 各种 **API** 也一般是用 HTTP + XML/json来实现的

:::

## 原理

::: tip
  什么是协议，一式双份/多份，双方都遵从的一个规范，这个规范就可以成为协议，计算机之所以能全世界互通，协议功不可没。如FTP协议、SMTP协议、HTTP协议等
:::

### HTTP 协议工作流程

::: tip
  首先客户端(如浏览器)和服务端是相互独立的，客户端要向服务端发请求时，必须先建立连接，连接可理解为网络上的虚拟电路，连接建立之后客户端发送请求，然后服务端沿着连接，返回响应信息。客户端接收响应，解释出图片或文字，然后断开连接，一次 HTTP 请求结束。

  下面看看一次请求中的详细过程
:::

### HTTP 请求信息和响应信息

#### 请求信息
::: tip
* 请求行 （GET /api/home.html HTTP/1.1）
  * 请求方法（GET、POST、PUT、DELETE、HEAD等）
    * 这些请求方法虽是HTTP协议里规定的，但服务器未必允许或支持这些方法
    * HEAD 和 GET 区别：HEAD 不返回主体信息，而 GET 请求会返回主体信息，当不需要服务器返回的主体信息时，可用 HEAD 方法
  * 请求路径
  * 所用协议
* 请求头信息（头信息结束后有一个空行，由这个空行来做区分，即使没有主体信息，空行也不能省略）
  * Host: 请求主机地址
  * Content-length: 接下来主体信息长度
  * Content-type: 主体数据格式
  * key: value
* 请求主体信息（可选）
:::

#### 响应信息
::: tip

* 响应行
  * 协议版本
  * 状态码
    * 1XX：接收到请求，继续处理
    * 2XX：操作成功收到、理解和接收
    * 3XX：为了完成请求，必须采取进一步措施
      * 301 ---- 永久重定向
      * 302 ---- 临时重定向 FOUND，响应头信息中会指定 **Location: 重定向地址** 信息
      * 304 ---- Not Modified 取浏览器缓存
      * 307 ---- 重定向中 **保持原有的请求数据**，针对 POST 等携带数据的请求方法
    * 4XX：客户端错误
    * 5XX：服务端错误
  * 状态文字（描述状态码文字，便于观察）
* 响应头信息
  * key: value
  * content-length: 接下来主体信息的长度
* 响应主体信息
:::

## HTTP 进阶

### 防盗链

::: tip
  如果在自己的网页里引用站外图片时，经常会出现图片无法访问的错误，那它们是怎么识别到图片是站外被引用的呢，或者一些网站是怎么实现统计用户是从哪个网站跳转过来的呢。原理是一样的，根据请求头信息中的 **Referer: 网页来源**，即上一页的地址，如果是直接在浏览器上输入地址访问的，则没有 Referer 头信息。

  那么怎么实现图片防盗链呢，在 web 服务器层面，根据 http 协议的 referer 头信息来判断如果来自站外，则返回相应措施。
:::

### 缓存详解

#### 协商缓存

::: tip
  我们观察图片的下载，往往第一次请求时，返回 200 OK，第二次请求时，返回 304 Not Modified。

  **原因：** 在网络上，有一些缓存服务器，另外，浏览器自身也有缓存功能，当我们第一次访问某图片时，正常下载，返回值 200，基于一个前提--图片不会经常改动，服务器在返回 200 的同时，还返回该图片的 "签名" -- ETag，Last-Modified，当浏览器再次访问该图片时，携带该"签名" -- If-None-Match，If-Modified-Since 去服务器校验该"签名"，如果图片没有变化，返回304  通知浏览器直接使用缓存中的图片，这样减轻了服务器的负担。
:::

#### 强制缓存

::: tip
  在一些大型网站，有N太缓存服务器，那么这些服务器如何处理主服务器上的文件，要不要让浏览器缓存这些文件，缓存多久，HTTP 协议有几个字段来实现这个功能的。

  **cache-control：** 告诉浏览器、缓存服务器以怎样的方式缓存资源

* no-store -- 不缓存，每次都向源服务器发请求，一般是网站首页
* must-revalidate -- 告诉浏览器、缓存服务器，在本地资源副本过期前，可以使用本地副本，本地副本一旦过期，必须去源服务器进行有效性校验
* no-cache -- 告诉浏览器或缓存服务器不管本地缓存是否过期，在使用资源副本前，都应先去资源源服务器校验资源有效性
* max-age等

**expires：** 资源过期时间，如果浏览器发现资源还在缓存有效期内，则不发起请求，减轻服务器压力
:::

### HTTP 内容压缩

::: tip
  在访问大型网站时，在它的请求响应头信息中，除了有 Content-length: value 信息，还会有一个 **Content-Encoding: gzip** 信息，此时 Content-length 的值和返回的主体长度不一致，原因在于为了提高网页在网络上的传输速度，服务器对主体信息进行了压缩，如常见的 gzip压缩、deflate压缩、compress压缩等，Content-length 为压缩后的长度。
:::

### HTTP Cookie

::: tip
  HTTP 请求是无状态的，即每次HTTP请求是独立的，服务器无法识别HTTP请求是哪个客户发起的，所以在对客户请求认证之后在响应头信息中通过 **Set-cookie** 字段标识客户，以后浏览器每次发起 HTTP 请求都必须在请求头信息中通过 **Cookie** 字段携带该信息给服务器识别。Cookie 也可能被盗，为安全起见现在都通过 **图片验证码**、**手机验证码** 来进行验证。
:::

（完）