# 正则表达式学习
---
*2020/11/22*

## 前言

::: tip
  **正则表达式**在前端的重要性无需多言，今天网上找了一篇得赞比较多的文章简单学习下正则表达式。
:::

## 正则基础知识点

### 元字符

::: tip
  **元字符** 是构造正则表达式的一种基本元素，常用的元字符有：

| 元字符 | 说明 |
| :-- | :-- |
| . | 匹配除换行符以外的任意字符 |
| \w | 匹配字母或数字或下划线或汉字 |
| \s | 匹配任意的空白符 |
| \d | 匹配数字 |
| \b | 匹配单词的开始或结束 |
| ^ | 匹配字符串的开始 |
| $ | 匹配字符串的结束 |
:::

### 重复限定符

::: tip
| 语法 | 说明 |
| :-- | :-- |
| * | 重复零次或更多次 |
| + | 重复一次或更多次 |
| ? | 重复零次或一次 |
| {n} | 重复n次 |
| {n,} | 重复n次或更多次 |
| {n,m} | 重复n到m次 |

  匹配1开头11位数字的手机号码
```regex
 ^1\d{10}$
```
:::

### 分组

::: tip
  如果想匹配以a开头的，0个或多个b结尾的字符串，写法如下:
```regex
^ab*$
```
  如果想要ab同时被*限定呢？可以使用小括号。**正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。** ，因此当要匹配多个ab时，可以这样：
```regex
^(ab)*
```
:::

### 转义

::: tip
  我们看到正则表达式用小括号来做分组，那 **如果要匹配的字符串中本身就包含小括号，那该怎么办**，针对这种情况，正则提供了转义的方式，也就是把这些元字符、限定符或者关键字转义成普通的字符，做法很简单，就是在要转义的字符前面加个斜杠(\\)即可。
```regex
^(\(ab\))*
```
:::

### 条件或

::: tip
  回到刚才的手机号匹配，我们都知道：国内号码都来自三大网，它们都有属于自己的号段，比如联通有 130/131/132/155/156/185/186/145/176等号段，假如让我们匹配一个联通的号码，那按照我们目前所学的正则，应该无从下手，因为这里包含了一些并列的条件，也就是“或”，那么在正则中是如何表示“或”的呢？

  **正则用户号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。**

  那么我们就可以用或条件来处理这个问题：
```regex
^(130|131|132|155|156|185|186|145|176)\d{8}$
```
:::


### 区间

::: tip
  上面的例子，还可以用区间继续简化。

  **正则提供一个元字符中括号来表示区间条件。**
  * 限定0到9可以写成 [0-9]
  * 限定A-Z写成 [A-Z]
  * 限定某些数字 [165]

  上面的正则可以改成：
```regex
^((13[0-2])|(15[56])|(18[5-6])|145|176)\d{8}$
```
:::

## 正则进阶知识点

### 零宽断言

::: tip
  无论是零宽还是断言，听起来都古古怪怪的，先解释下这两个词。

  **断言：** 俗话的断言就是 "我断定什么什么"，而正则中的断言，就是说正则可以指明在指定的内容前面或后面会出现满足指定规则的内容，意思是正则也可以像人类那样断定什么什么，比如 "ss1aa2bb3"，正则可以用断言找出aa2前面有ss1，也可以找出aa2后面有bb3。

  **零宽：** 也就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。

  听了还是糊里糊涂，举个例子吧

  假设我们要用爬虫取 csdn 里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构：
```html
"<span class="read-count">阅读数：641</span>"
```
  其中也就 '641' 这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得里边的 '641' 有很多种办法，但是正则应该怎么匹配呢？

  下面先讲几种类型的断言。
:::

#### 正向先行断言(正前瞻)

::: tip
  **语法：** (?=pattern)
  **作用：** 匹配pattern表达式的前面内容，不返回本身。

  回到刚才的例子，要取阅读量，在正则表达式中就意味着要能匹配到 `'</span>'` 前面的数字内容。按照上所说的正向先行断言可以匹配表达式前面的内容，那意思就是: (?=<\/span>) 就可以匹配到前面的内容了。

``` js
const str = '<span class="read-count">阅读数：641</span>'
const reg = /.+(?=<\/span>)/

const ret = reg.exec(str)
console.log(ret[0]) // <span class="read-count">阅读数：641
```

  我们只要阅读数 '641' ，那也简单，匹配数字 \d，那可以改成：

```js
const str = '<span class="read-count">阅读数：641</span>'
const reg = /\d+(?=<\/span>)/

const ret = reg.exec(str)
console.log(ret[0]) // 641
```
:::

#### 正向后行断言(正后顾)

::: tip
  **语法：** (?<=pattern)
  **作用：** 匹配pattern表达式的后面的内容，不返回本身。

  有先行就有后行，先行是匹配前面的内容，那后行就是匹配后面的内容。

  上面的例子，我们也可以用后行断言来处理。

```js
const str = '<span class="read-count">阅读数：641</span>'
const reg = /(?<=\<span class=\"read-count\">阅读数：)\d+/

const ret = reg.exec(str)
console.log(ret[0]) // 641
```
:::

#### 负向先行断言(负前瞻)

::: tip
  **语法：** (?!pattern)
  **作用：** 匹配非pattern表达式的前面的内容，不返回本身。

  有正向也有负向，负向在这里其实是非的意思。

  举个例子：比如有一句  "我爱祖国, 我是祖国的花朵"

  现在要找到不是 "的花朵" 前面的祖国，用正则就可以这样写：

```regex
祖国(?!的花朵)
```
:::

#### 负向后行断言(负后顾)

::: tip
  **语法：** (?<!pattern)
  **作用：** 匹配非pattern表达式的后面的内容，不返回本身。
:::

### 贪婪和非贪婪

#### 贪婪

::: tip
  我们都知道，贪婪是不满足，尽可能多的要，在正则中，贪婪也是差不多的意思：

  **贪婪匹配：** 当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。

  **特性：** 一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。

  前面我们讲过重复限定符，其实这些限定符就是贪婪量词，比如表达式：

```regex
\d{3,6}
```
  用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个数字可以匹配，那它就全部匹配到，如：
```js
const str = '61762828 176 2991 44 871'
const reg = /\d{3,6}/g

let res
while((res = reg.exec(str)) !== null) {
  console.log(res[0])
}
/*
617628
176   
2991  
871  
*/
```

  由结果可见：本来字符串中的 '61762828' 这一段，其实只需要出现3个(617) 就已经匹配成功了的，但是它并不满足，而是匹配到了最大能匹配的字符，也就是6个。

  如果多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？

  是这样的，多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，就会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。如：
```js
const str = '61762828 176 2991 87321'
const reg = /(\d{1,2})(\d{3,4})/g

let res
while((res = reg.exec(str)) !== null) {
  console.log(res[0])
}
/*
617628  前面 \d{1,2}匹配出了61，后面匹配出了 7628
2991    前面 \d{1,2}匹配出了2，后面匹配出了 991
87321   前面 \d{1,2}匹配出了97，后面匹配出了 321
*/
```
:::

#### 非贪婪

::: tip
  **懒惰匹配：** 当正则表达式中包含能接受重复的限定符时，通常的行为是（在屎整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配 方式叫做懒惰匹配。

  **特性：** 从左到右，从字符串的最左边开始匹配，每次视图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依次循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。

  懒惰量词是在贪婪量词后面加个 '?'

  | 代码 | 说明 |
  | :-- | :-- |
  | *? | 重复任意次，但尽可能少重复 |
  | +? | 重复1次或更多次，但尽可能少重复 |
  | ?? | 重复0次或1次，但尽可能少重复 |
  | {n,m}? | 重复n到m次，但尽可能少重复 |
  | {n,}? | 重复n次以上，但尽可能少重复 |

```js
const str = '61762828 176 2991 87321'
const reg = /(\d{1,2}?)(\d{3,4})/g

let res
while((res = reg.exec(str)) !== null) {
  console.log(res[0])
}
/*
61762   左边的懒惰匹配出6，右边的贪婪匹配出1762
2991    左边的懒惰匹配出2，右边的贪婪匹配出991
87321   左边的懒惰匹配出8，右边的贪婪匹配出7321
*/
```
:::

### 反义

::: tip
  前面说到元字符的都是要匹配什么什么，当然如果想反着来，不想匹配某些字符，正则也提供了一些常用的反义元字符：

| 元字符 | 解释 |
| :-- | :-- |
| \W | 匹配任意不是字母、数字、下划线、汉语的字符 |
| \S | 匹配任意不是空白符的字符 |
| \D | 匹配任意非数字的字符 |
| \B | 匹配不是单词开头或结尾的位置 |
| [^x] | 匹配除了x以外的任意字符 |
| [^aeiou] | 匹配除了aeiou 这几个字母以外的任意字符 |
:::

::: tip
  [参考链接](https://www.zhihu.com/question/48219401)

  [回首页](/frontend)
:::

（完）