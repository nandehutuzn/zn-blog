(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{438:function(a,t,s){"use strict";s.r(t);var e=s(41),r=Object(e.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"v8-引擎垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8-引擎垃圾回收机制"}},[a._v("#")]),a._v(" V8 引擎垃圾回收机制")]),a._v(" "),s("hr"),a._v(" "),s("p",[s("em",[a._v("2020/11/10")])]),a._v(" "),s("h2",{attrs:{id:"前言"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[a._v("#")]),a._v(" 前言")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("很多编程语言(如JavaScript、C#、Java)开发者在开发过程中很少遇到需要对内存精准控制的场景了，而在 C、C++ 里面是必须由开发者自己控制，做出这一改变的原因是前者在语言底层自动帮我们进行了垃圾回收处理，但在程序实际运转过程中还是会出现 "),s("strong",[a._v("内存泄漏")]),a._v(" 的异常，这次就来看看Chrome 和 Node 使用的 V8 引擎底层的垃圾回收是怎样一个过程。")])]),a._v(" "),s("h2",{attrs:{id:"v8-垃圾回收机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v8-垃圾回收机制"}},[a._v("#")]),a._v(" V8 垃圾回收机制")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("V8 的垃圾回收策略主要是基于分代式垃圾回收机制。在自动垃圾回收的演变过程中，人们发现没有一种垃圾回收算法能够胜任所有的场景。因为在实际的应用中，对象的生存周期长短不一，不同的算法只能针对特定情况具有最好的效果。现代的垃圾回收算法中，按对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法。")]),a._v(" "),s("p",[s("strong",[a._v("内存分代：")]),a._v(" 在 V8 中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。即 V8 堆的整体大小就是新生代所用内存空间加上老生代的内存空间。")]),a._v(" "),s("p",[a._v("V8 在新生代和老生代之间根据对象存活的特点分别用了不同的垃圾回收算法，下面分别看看。")])]),a._v(" "),s("h2",{attrs:{id:"新生代"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#新生代"}},[a._v("#")]),a._v(" 新生代")]),a._v(" "),s("h3",{attrs:{id:"scavenge-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scavenge-算法"}},[a._v("#")]),a._v(" Scavenge 算法")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("在新生代堆中，采用复制的方式实现垃圾回收。首先将堆内存一分为二，每一部分空间称为 semispace。在这两个 semispace 空间中，只有一个处于使用中，另一个处于闲置状态。处于使用状态的 semispace 空间称为 From 空间，处于闲置状态的空间称为 To 空间。当我们分配对象时，先是在 From 空间中进行分配。当开始进行垃圾回收时，会检查 From 空间中的存活对象，这些存活对象将被复制到 To 空间，而非存活对象占用的空间将被释放。完成赋值后，From 空间和 To 空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个semispace 空间之间进行复制。")]),a._v(" "),s("p",[a._v("Scavenge 的缺点是只能使用堆内存的一半，这是由划分空间和复制机制所决定的。但是 Scavenge 由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的表现。")]),a._v(" "),s("p",[a._v("Scavenge 是典型的牺牲空间换取时间的算法，所以无法大规模地应用到所有垃圾回收中。但是可以发现，Scavenge 非常适合应用在新生代中，因为新生代中对象的生命周期较短，刚好适合这个算法。")])]),a._v(" "),s("h2",{attrs:{id:"老生代"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#老生代"}},[a._v("#")]),a._v(" 老生代")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被转移到老生代中，采用新的算法进行管理。对象被转移的条件有两个，一个是对象是否经历过 Scavenge 回收，一个是 To 空间的内存占用比超过限制。")]),a._v(" "),s("p",[a._v("对于老生代中的对象，由于存活对象占较大比重，再采用 Scavenge 的方式会有两个问题：一是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。所以老生代中主要采用了 Mark-Sweep 和 Mark-Compact 相结合的 方式进行垃圾回收。")])]),a._v(" "),s("h3",{attrs:{id:"mark-sweep-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mark-sweep-算法"}},[a._v("#")]),a._v(" Mark-Sweep 算法")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("Mark-Sweep 是标记清除的意思，它分为标记和清除两个阶段。Mark-Sweep 在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。可以看出， Scavenge 中只复制活着的对象，而 Mark-Sweep 只清理死亡的对象。活对象在新生代中只占较小部分，死对象在老生代中只占较小部分，这是两种回收方式能高效处理的原因。")]),a._v(" "),s("p",[a._v("Mark-Sweep 最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的，为了解决 Mark-Sweep 的内存碎片问题，Mark-Compact 被提出来。")])]),a._v(" "),s("h3",{attrs:{id:"mark-compact-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mark-compact-算法"}},[a._v("#")]),a._v(" Mark-Compact 算法")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("Mark-Compact 是标记整理的意思，是在 Mark-Sweep 的基础上演变而来的。它们的差别在于对象在标记为存活后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。")])]),a._v(" "),s("h2",{attrs:{id:"优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化"}},[a._v("#")]),a._v(" 优化")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[a._v('为避免出现 JavaScript 应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑站厅下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为 "全停顿"(stop-the-world)。新生代中存活对象比较少，影响不大，但是在老生代中，存活对象比较多，全堆垃圾回收的标记、清理、整理等动作的停顿就会比较可怕，需要设法改善。')])]),a._v(" "),s("h3",{attrs:{id:"incremental-marking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#incremental-marking"}},[a._v("#")]),a._v(" Incremental Marking")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[a._v('为了降低全堆垃圾回收带来的停顿时间，V8 先从标记阶段入手，将原先要一口气停顿完成的动作改为增量标记(incremental marking)，也就是拆分为许多小 "步进"，每做完一 "步进" 就让 JavaScript 应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记完成。V8 在经过增量标记的改进后，垃圾回收的最大停顿时间可减少到原本的 1/6 左右。')])]),a._v(" "),s("h3",{attrs:{id:"其他优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其他优化"}},[a._v("#")]),a._v(" 其他优化")]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",[a._v("V8 后续还引入了 "),s("strong",[a._v("延迟清理(lazy sweeping)")]),a._v(" 与 "),s("strong",[a._v("增量式整理(incremental compaction)")]),a._v("，让清理与整理的工作也变成增量式的。同时还引入并行标记与并行清理，进一步利用多核性能降低每次停顿的时间。经测算 V8 每执行 1000ms，有大约 54ms 在进行垃圾回收（2014年数据）")]),a._v(" "),s("p",[a._v("本文参考 《深入浅出Node.js》")]),a._v(" "),s("p",[s("a",{attrs:{href:"/frontend"}},[a._v("回首页")])])]),a._v(" "),s("p",[a._v("（完）")])])}),[],!1,null,null,null);t.default=r.exports}}]);